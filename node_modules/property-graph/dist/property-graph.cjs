class EventDispatcher {
  constructor() {
    this._listeners = {};
  }

  addEventListener(type, listener) {
    const listeners = this._listeners;

    if (listeners[type] === undefined) {
      listeners[type] = [];
    }

    if (listeners[type].indexOf(listener) === -1) {
      listeners[type].push(listener);
    }

    return this;
  }

  removeEventListener(type, listener) {
    if (this._listeners === undefined) return this;
    const listeners = this._listeners;
    const listenerArray = listeners[type];

    if (listenerArray !== undefined) {
      const index = listenerArray.indexOf(listener);

      if (index !== -1) {
        listenerArray.splice(index, 1);
      }
    }

    return this;
  }

  dispatchEvent(event) {
    if (this._listeners === undefined) return this;
    const listeners = this._listeners;
    const listenerArray = listeners[event.type];

    if (listenerArray !== undefined) {
      // Make a copy, in case listeners are removed while iterating.
      const array = listenerArray.slice(0);

      for (let i = 0, l = array.length; i < l; i++) {
        array[i].call(this, event);
      }
    }

    return this;
  }

  dispose() {
    for (const key in this._listeners) {
      delete this._listeners[key];
    }
  }

}

/**
 * Represents a connection between two {@link GraphNode} resources in a {@link Graph}.
 *
 * The left node is considered the owner, and the right node the resource. The
 * owner is responsible for being able find and remove a reference to a resource, given
 * that link. The resource does not hold a reference to the link or to the owner,
 * although that reverse lookup can be done on the graph.
 */

class GraphEdge extends EventDispatcher {
  constructor(_name, _parent, _child, _attributes) {
    if (_attributes === void 0) {
      _attributes = {};
    }

    super();
    this._name = void 0;
    this._parent = void 0;
    this._child = void 0;
    this._attributes = void 0;
    this._disposed = false;
    this._name = _name;
    this._parent = _parent;
    this._child = _child;
    this._attributes = _attributes;

    if (!_parent.isOnGraph(_child)) {
      throw new Error('Cannot connect disconnected graphs.');
    }
  }
  /** Name. */


  getName() {
    return this._name;
  }
  /** Owner node. */


  getParent() {
    return this._parent;
  }
  /** Resource node. */


  getChild() {
    return this._child;
  }
  /**
   * Sets the child node.
   *
   * @internal Only {@link Graph} implementations may safely call this method directly. Use
   * 	{@link Property.swap} or {@link Graph.swapChild} instead.
   */


  setChild(child) {
    this._child = child;
    return this;
  }
  /** Attributes of the graph node relationship. */


  getAttributes() {
    return this._attributes;
  }
  /** Destroys a (currently intact) edge, updating both the graph and the owner. */


  dispose() {
    if (this._disposed) return;
    this._disposed = true;
    this.dispatchEvent({
      type: 'dispose',
      target: this
    });
    super.dispose();
  }
  /** Whether this link has been destroyed. */


  isDisposed() {
    return this._disposed;
  }

}

/**
 * A graph manages a network of {@link GraphNode} nodes, connected
 * by {@link @Link} edges.
 */

class Graph extends EventDispatcher {
  constructor() {
    super(...arguments);
    this._emptySet = new Set();
    this._edges = new Set();
    this._parentEdges = new Map();
    this._childEdges = new Map();
  }

  /** Returns a list of all parent->child edges on this graph. */
  listEdges() {
    return Array.from(this._edges);
  }
  /** Returns a list of all edges on the graph having the given node as their child. */


  listParentEdges(node) {
    return Array.from(this._childEdges.get(node) || this._emptySet);
  }
  /** Returns a list of parent nodes for the given child node. */


  listParents(node) {
    return this.listParentEdges(node).map(edge => edge.getParent());
  }
  /** Returns a list of all edges on the graph having the given node as their parent. */


  listChildEdges(node) {
    return Array.from(this._parentEdges.get(node) || this._emptySet);
  }
  /** Returns a list of child nodes for the given parent node. */


  listChildren(node) {
    return this.listChildEdges(node).map(edge => edge.getChild());
  }

  disconnectParents(node, filter) {
    let edges = this.listParentEdges(node);

    if (filter) {
      edges = edges.filter(edge => filter(edge.getParent()));
    }

    edges.forEach(edge => edge.dispose());
    return this;
  }
  /**
   * Creates a {@link GraphEdge} connecting two {@link GraphNode} instances. Edge is returned
   * for the caller to store.
   * @param a Owner
   * @param b Resource
   */


  createEdge(name, a, b, attributes) {
    return this._registerEdge(new GraphEdge(name, a, b, attributes));
  }
  /**********************************************************************************************
   * Internal.
   */

  /** @hidden */


  _registerEdge(edge) {
    this._edges.add(edge);

    const parent = edge.getParent();
    if (!this._parentEdges.has(parent)) this._parentEdges.set(parent, new Set());

    this._parentEdges.get(parent).add(edge);

    const child = edge.getChild();
    if (!this._childEdges.has(child)) this._childEdges.set(child, new Set());

    this._childEdges.get(child).add(edge);

    edge.addEventListener('dispose', () => this._removeEdge(edge));
    return edge;
  }
  /**
   * Removes the {@link GraphEdge} from the {@link Graph}. This method should only
   * be invoked by the onDispose() listener created in {@link _registerEdge()}. The
   * public method of removing an edge is {@link GraphEdge.dispose}.
   */


  _removeEdge(edge) {
    this._edges.delete(edge);

    this._parentEdges.get(edge.getParent()).delete(edge);

    this._childEdges.get(edge.getChild()).delete(edge);

    return this;
  }

}

function isRef(value) {
  return value instanceof GraphEdge;
}
function isRefList(value) {
  return Array.isArray(value) && value[0] instanceof GraphEdge;
}
function isRefMap(value) {
  return !!(isPlainObject(value) && getFirstValue(value) instanceof GraphEdge);
}

function getFirstValue(value) {
  for (const key in value) {
    return value[key];
  }
}

function isPlainObject(value) {
  return Boolean(value) && Object.getPrototypeOf(value) === Object.prototype;
}

const $attributes = Symbol('attributes');
const $immutableKeys = Symbol('immutableKeys');
/**
 * Represents a node in a {@link Graph}.
 */

class GraphNode extends EventDispatcher {
  /**
   * Internal graph used to search and maintain references.
   * @hidden
   */

  /**
   * Attributes (literal values and GraphNode references) associated with this instance. For each
   * GraphNode reference, the attributes stores a {@link GraphEdge}. List and Map references are
   * stored as arrays and dictionaries of edges.
   * @internal
   */

  /**
   * Attributes included with `getDefaultAttributes` are considered immutable, and cannot be
   * modifed by `.setRef()`, `.copy()`, or other GraphNode methods. Both the edges and the
   * properties will be disposed with the parent GraphNode.
   *
   * Currently, only single-edge references (getRef/setRef) are supported as immutables.
   *
   * @internal
   */
  constructor(graph) {
    super();
    this._disposed = false;
    this.graph = void 0;
    this[$attributes] = void 0;
    this[$immutableKeys] = void 0;
    this.graph = graph;
    this[$immutableKeys] = new Set();
    this[$attributes] = this._createAttributes();
  }
  /**
   * Returns default attributes for the graph node. Subclasses having any attributes (either
   * literal values or references to other graph nodes) must override this method. Literal
   * attributes should be given their default values, if any. References should generally be
   * initialized as empty (Ref → null, RefList → [], RefMap → {}) and then modified by setters.
   *
   * Any single-edge references (setRef) returned by this method will be considered immutable,
   * to be owned by and disposed with the parent node. Multi-edge references (addRef, removeRef,
   * setRefMap) cannot be returned as default attributes.
   */


  getDefaults() {
    return {};
  }
  /**
   * Constructs and returns an object used to store a graph nodes attributes. Compared to the
   * default Attributes interface, this has two distinctions:
   *
   * 1. Slots for GraphNode<T> objects are replaced with slots for GraphEdge<this, GraphNode<T>>
   * 2. GraphNode<T> objects provided as defaults are considered immutable
   *
   * @internal
   */


  _createAttributes() {
    const defaultAttributes = this.getDefaults();
    const attributes = {};

    for (const key in defaultAttributes) {
      const value = defaultAttributes[key];

      if (value instanceof GraphNode) {
        const ref = this.graph.createEdge(key, this, value);
        ref.addEventListener('dispose', () => value.dispose());
        this[$immutableKeys].add(key);
        attributes[key] = ref;
      } else {
        attributes[key] = value;
      }
    }

    return attributes;
  }
  /** @internal Returns true if two nodes are on the same {@link Graph}. */


  isOnGraph(other) {
    return this.graph === other.graph;
  }
  /** Returns true if the node has been permanently removed from the graph. */


  isDisposed() {
    return this._disposed;
  }
  /**
   * Removes both inbound references to and outbound references from this object. At the end
   * of the process the object holds no references, and nothing holds references to it. A
   * disposed object is not reusable.
   */


  dispose() {
    if (this._disposed) return;
    this.graph.listChildEdges(this).forEach(edge => edge.dispose());
    this.graph.disconnectParents(this);
    this._disposed = true;
    this.dispatchEvent({
      type: 'dispose'
    });
  }
  /**
   * Removes all inbound references to this object. At the end of the process the object is
   * considered 'detached': it may hold references to child resources, but nothing holds
   * references to it. A detached object may be re-attached.
   */


  detach() {
    this.graph.disconnectParents(this);
    return this;
  }
  /**
   * Transfers this object's references from the old node to the new one. The old node is fully
   * detached from this parent at the end of the process.
   *
   * @hidden
   */


  swap(old, replacement) {
    for (const attribute in this[$attributes]) {
      const value = this[$attributes][attribute];

      if (isRef(value)) {
        const ref = value;

        if (ref.getChild() === old) {
          this.setRef(attribute, replacement, ref.getAttributes());
        }
      } else if (isRefList(value)) {
        const refs = value;
        const ref = refs.find(ref => ref.getChild() === old);

        if (ref) {
          const refAttributes = ref.getAttributes();
          this.removeRef(attribute, old).addRef(attribute, replacement, refAttributes);
        }
      } else if (isRefMap(value)) {
        const refMap = value;

        for (const key in refMap) {
          const ref = refMap[key];

          if (ref.getChild() === old) {
            this.setRefMap(attribute, key, replacement, ref.getAttributes());
          }
        }
      }
    }

    return this;
  }
  /**********************************************************************************************
   * Literal attributes.
   */

  /** @hidden */


  get(attribute) {
    return this[$attributes][attribute];
  }
  /** @hidden */


  set(attribute, value) {
    this[$attributes][attribute] = value;
    return this.dispatchEvent({
      type: 'change',
      attribute
    });
  }
  /**********************************************************************************************
   * Ref: 1:1 graph node references.
   */

  /** @hidden */


  getRef(attribute) {
    const ref = this[$attributes][attribute];
    return ref ? ref.getChild() : null;
  }
  /** @hidden */


  setRef(attribute, value, attributes) {
    if (this[$immutableKeys].has(attribute)) {
      throw new Error("Cannot overwrite immutable attribute, \"" + attribute + "\".");
    }

    const prevRef = this[$attributes][attribute];
    if (prevRef) prevRef.dispose(); // TODO(cleanup): Possible duplicate event.

    if (!value) return this;
    const ref = this.graph.createEdge(attribute, this, value, attributes);
    ref.addEventListener('dispose', () => {
      delete this[$attributes][attribute];
      this.dispatchEvent({
        type: 'change',
        attribute
      });
    });
    this[$attributes][attribute] = ref;
    return this.dispatchEvent({
      type: 'change',
      attribute
    });
  }
  /**********************************************************************************************
   * RefList: 1:many graph node references.
   */

  /** @hidden */


  listRefs(attribute) {
    const refs = this[$attributes][attribute];
    return refs.map(ref => ref.getChild());
  }
  /** @hidden */


  addRef(attribute, value, attributes) {
    const ref = this.graph.createEdge(attribute, this, value, attributes);
    const refs = this[$attributes][attribute];
    refs.push(ref);
    ref.addEventListener('dispose', () => {
      let index;

      while ((index = refs.indexOf(ref)) !== -1) {
        refs.splice(index, 1);
      }

      this.dispatchEvent({
        type: 'change',
        attribute
      });
    });
    return this.dispatchEvent({
      type: 'change',
      attribute
    });
  }
  /** @hidden */


  removeRef(attribute, value) {
    const refs = this[$attributes][attribute];
    const pruned = refs.filter(ref => ref.getChild() === value);
    pruned.forEach(ref => ref.dispose()); // TODO(cleanup): Possible duplicate event.

    return this;
  }
  /**********************************************************************************************
   * RefMap: Named 1:many (map) graph node references.
   */

  /** @hidden */


  listRefMapKeys(key) {
    return Object.keys(this[$attributes][key]);
  }
  /** @hidden */


  listRefMapValues(key) {
    return Object.values(this[$attributes][key]).map(ref => ref.getChild());
  }
  /** @hidden */


  getRefMap(attribute, key) {
    const refMap = this[$attributes][attribute];
    return refMap[key] ? refMap[key].getChild() : null;
  }
  /** @hidden */


  setRefMap(attribute, key, value, metadata) {
    const refMap = this[$attributes][attribute];
    const prevRef = refMap[key];
    if (prevRef) prevRef.dispose(); // TODO(cleanup): Possible duplicate event.

    if (!value) return this;
    metadata = Object.assign(metadata || {}, {
      key: key
    });
    const ref = this.graph.createEdge(attribute, this, value, { ...metadata,
      key
    });
    ref.addEventListener('dispose', () => {
      delete refMap[key];
      this.dispatchEvent({
        type: 'change',
        attribute,
        key
      });
    });
    refMap[key] = ref;
    return this.dispatchEvent({
      type: 'change',
      attribute,
      key
    });
  }
  /**********************************************************************************************
   * Events.
   */

  /**
   * Dispatches an event on the GraphNode, and on the associated
   * Graph. Event types on the graph are prefixed, `"node:[type]"`.
   */


  dispatchEvent(event) {
    super.dispatchEvent({ ...event,
      target: this
    });
    this.graph.dispatchEvent({ ...event,
      target: this,
      type: "node:" + event.type
    });
    return this;
  }

}

exports.$attributes = $attributes;
exports.$immutableKeys = $immutableKeys;
exports.EventDispatcher = EventDispatcher;
exports.Graph = Graph;
exports.GraphEdge = GraphEdge;
exports.GraphNode = GraphNode;
exports.isRef = isRef;
exports.isRefList = isRefList;
exports.isRefMap = isRefMap;
//# sourceMappingURL=property-graph.cjs.map
