{"version":3,"file":"docs.js","sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/is-plain-object/index.js","webpack:///./src/acolorpicker.js","webpack:///./node_modules/is-plain-object/node_modules/isobject/index.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","/*!\n * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nvar isObject = require('isobject');\n\nfunction isObjectObject(o) {\n  return isObject(o) === true\n    && Object.prototype.toString.call(o) === '[object Object]';\n}\n\nmodule.exports = function isPlainObject(o) {\n  var ctor,prot;\n\n  if (isObjectObject(o) === false) return false;\n\n  // If has modified constructor\n  ctor = o.constructor;\n  if (typeof ctor !== 'function') return false;\n\n  // If has modified prototype\n  prot = ctor.prototype;\n  if (isObjectObject(prot) === false) return false;\n\n  // If constructor does not have an Object-specific method\n  if (prot.hasOwnProperty('isPrototypeOf') === false) {\n    return false;\n  }\n\n  // Most likely a plain Object\n  return true;\n};\n","// @ts-check\n/*!\n * a-color-picker\n * https://github.com/narsenico/a-color-picker\n *\n * Copyright (c) 2017-2019, Gianfranco Caldi.\n * Released under the MIT License.\n */\n\nimport {\n    COLOR_NAMES,\n    PALETTE_MATERIAL_500,\n    PALETTE_MATERIAL_CHROME,\n    rgbToHex,\n    hslToRgb,\n    rgbToHsl,\n    rgbToHsv,\n    rgbToInt,\n    intToRgb,\n    cssColorToRgb,\n    parseColorToRgb,\n    parseColorToRgba,\n    parseColorToHsl,\n    parseColorToHsla,\n    parseColor,\n    getLuminance,\n    limit,\n    ensureArray,\n    nvl\n} from './utils.js';\nimport isPlainObject from 'is-plain-object';\nimport HTML_BOX from './acolorpicker.html';\n\nconst VERSION = '1.2.1';\n\nconst IS_EDGE = typeof window !== 'undefined' && window.navigator.userAgent.indexOf('Edge') > -1,\n    IS_IE11 = typeof window !== 'undefined' && window.navigator.userAgent.indexOf('rv:') > -1;\n\nconst DEFAULT = {\n    id: null,\n    attachTo: 'body',\n    showHSL: true,\n    showRGB: true,\n    showHEX: true,\n    showAlpha: false,\n    color: '#ff0000',\n    palette: null,\n    paletteEditable: false,\n    useAlphaInPalette: 'auto', //true|false|auto\n    slBarSize: [232, 150],\n    hueBarSize: [150, 11],\n    alphaBarSize: [150, 11]\n};\n\nconst HUE = 'H',\n    SATURATION = 'S',\n    LUMINANCE = 'L',\n    RGB = 'RGB',\n    RED = 'R',\n    GREEN = 'G',\n    BLUE = 'B',\n    RGBHEX = 'RGBHEX',\n    COLOR = 'COLOR',\n    RGBA_USER = 'RGBA_USER',\n    HSLA_USER = 'HSLA_USER',\n    ALPHA = 'ALPHA';\n\nfunction parseElement(element, defaultElement, fallToDefault) {\n    if (!element) {\n        return defaultElement;\n    } else if (element instanceof HTMLElement) {\n        return element;\n    } else if (element instanceof NodeList) {\n        return element[0];\n    } else if (typeof element == 'string') {\n        return document.querySelector(element);\n    } else if (element.jquery) {\n        return element.get(0); //TODO: da testare parseElement con jQuery\n    } else if (fallToDefault) {\n        return defaultElement;\n    } else {\n        return null;\n    }\n}\n\nfunction parseElements(selector) {\n    if (!selector) {\n        return [];\n    } else if (Array.isArray(selector)) {\n        return selector;\n    } else if (selector instanceof HTMLElement) {\n        return [selector];\n    } else if (selector instanceof NodeList) {\n        return [...selector];\n    } else if (typeof selector == 'string') {\n        return [...document.querySelectorAll(selector)];\n    } else if (selector.jquery) {\n        return selector.get(); //TODO: da testare parseElements con jQuery\n    } else {\n        return [];\n    }\n}\n\nfunction canvasHelper(canvas) {\n    const ctx = canvas.getContext('2d'),\n        width = +canvas.width,\n        height = +canvas.height;\n    // questo gradiente da bianco (alto) a nero (basso) viene applicato come sfondo al canvas\n    const whiteBlackGradient = ctx.createLinearGradient(1, 1, 1, height - 1);\n    whiteBlackGradient.addColorStop(0, 'white');\n    whiteBlackGradient.addColorStop(1, 'black');\n    return {\n        setHue(hue) {\n            // gradiente con il colore relavito a lo HUE da sinistra a destra partendo da trasparente a opaco\n            // la combinazione del gradiente bianco/nero e questo permette di avere un canvas dove\n            // sull'asse delle ordinate è espressa la saturazione, e sull'asse delle ascisse c'è la luminosità\n            const colorGradient = ctx.createLinearGradient(1, 0, width - 1, 0);\n            colorGradient.addColorStop(0, `hsla(${hue}, 100%, 50%, 0)`);\n            colorGradient.addColorStop(1, `hsla(${hue}, 100%, 50%, 1)`);\n            // applico i gradienti\n            ctx.fillStyle = whiteBlackGradient;\n            ctx.fillRect(0, 0, width, height);\n            ctx.fillStyle = colorGradient;\n            ctx.globalCompositeOperation = 'multiply';\n            ctx.fillRect(0, 0, width, height);\n            ctx.globalCompositeOperation = 'source-over';\n        },\n\n        grabColor(x, y) {\n            // recupera il colore del pixel in formato RGBA\n            return ctx.getImageData(x, y, 1, 1).data;\n        },\n\n        findColor(r, g, b) {\n            const [, s, v] = rgbToHsv(r, g, b);\n            const x = s * width;\n            const y = height - (v * height);\n            return [x, y];\n        }\n    };\n}\n\nfunction parseAttrBoolean(value, ifNull, ifEmpty) {\n    if (value === null) {\n        return ifNull;\n    } else if (/^\\s*$/.test(value)) {\n        return ifEmpty;\n    } else if (/true|yes|1/i.test(value)) {\n        return true;\n    } else if (/false|no|0/i.test(value)) {\n        return false;\n    } else {\n        return ifNull;\n    }\n}\n\nfunction parseAttrDimensionArray(value, ifNull, ifEmpty) {\n    if (value === null) {\n        return ifNull;\n    } else if (/^\\s*$/.test(value)) {\n        return ifEmpty;\n    } else {\n        const dimensions = value.split(',').map(Number);\n        if (dimensions.length === 2 && dimensions[0] && dimensions[1]) {\n            return dimensions\n        }\n        return ifNull;\n    }\n}\n\nfunction copyOptionsFromElement(options, element, attrPrefix = 'acp-') {\n    // getAttribute() dovrebbe restituire null se l'attr non esiste, ma le vecchie specifiche prevedono il ritorno di una stringa vuota\n    //  quindi è meglio verificare l'esistenza dell'attr con hasAttribute()\n    if (element.hasAttribute(attrPrefix + 'show-hsl')) {\n        options.showHSL = parseAttrBoolean(element.getAttribute(attrPrefix + 'show-hsl'), DEFAULT.showHSL, true);\n    }\n    if (element.hasAttribute(attrPrefix + 'show-rgb')) {\n        options.showRGB = parseAttrBoolean(element.getAttribute(attrPrefix + 'show-rgb'), DEFAULT.showRGB, true);\n    }\n    if (element.hasAttribute(attrPrefix + 'show-hex')) {\n        options.showHEX = parseAttrBoolean(element.getAttribute(attrPrefix + 'show-hex'), DEFAULT.showHEX, true);\n    }\n    if (element.hasAttribute(attrPrefix + 'show-alpha')) {\n        options.showAlpha = parseAttrBoolean(element.getAttribute(attrPrefix + 'show-alpha'), DEFAULT.showAlpha, true);\n    }\n    if (element.hasAttribute(attrPrefix + 'palette-editable')) {\n        options.paletteEditable = parseAttrBoolean(element.getAttribute(attrPrefix + 'palette-editable'), DEFAULT.paletteEditable, true);\n    }\n    if (element.hasAttribute(attrPrefix + 'sl-bar-size')) {\n        options.slBarSize = parseAttrDimensionArray(element.getAttribute(attrPrefix + 'sl-bar-size'), DEFAULT.slBarSize, [232, 150]);\n    }\n    if (element.hasAttribute(attrPrefix + 'hue-bar-size')) {\n        options.hueBarSize = parseAttrDimensionArray(element.getAttribute(attrPrefix + 'hue-bar-size'), DEFAULT.hueBarSize, [150, 11]);\n        options.alphaBarSize = options.hueBarSize\n    }\n    if (element.hasAttribute(attrPrefix + 'palette')) {\n        const palette = element.getAttribute(attrPrefix + 'palette');\n        switch (palette) {\n            case 'PALETTE_MATERIAL_500':\n                options.palette = PALETTE_MATERIAL_500;\n                break;\n            case 'PALETTE_MATERIAL_CHROME':\n            case '':\n                options.palette = PALETTE_MATERIAL_CHROME;\n                break;\n            default:\n                options.palette = palette.split(/[;|]/);\n                break;\n        }\n    }\n    if (element.hasAttribute(attrPrefix + 'color')) {\n        options.color = element.getAttribute(attrPrefix + 'color');\n    }\n}\n\nclass ColorPicker {\n    constructor(container, options) {\n        //controllo se siamo nel caso di options passato come primo parametro\n        if (options) {\n            container = parseElement(container);\n            this.options = Object.assign({}, DEFAULT, options);\n        } else if (container && isPlainObject(container)) {\n            // se non trovo options e container è un {} lo considero il vero options\n            this.options = Object.assign({}, DEFAULT, container);\n            container = parseElement(this.options.attachTo);\n        } else {\n            // altrimenti uso le opzioni di default\n            this.options = Object.assign({}, DEFAULT);\n            // nel caso non vengano proprio passati parametri, considero attachTo di default\n            container = parseElement(nvl(container, this.options.attachTo));\n        }\n\n        if (container) {\n            // le opzioni possono essere specificate come attributi dell'elemento contenitore\n            // quelle presenti sostituiranno le corrispondenti passate con il parametro options\n            copyOptionsFromElement(this.options, container);\n\n            this.H = 0;\n            this.S = 0;\n            this.L = 0;\n            this.R = 0;\n            this.G = 0;\n            this.B = 0;\n            this.A = 1;\n            // andrà a contenere la palette di colori effettivamente usata\n            // compresi i colori aggiunti o rimossi dall'utente, non sarà modificabile dirretamente dall'utente\n            this.palette = { /*<color>: boolean*/ };\n\n            // creo gli elementi HTML e li aggiungo al container\n            this.element = document.createElement('div');\n            if (this.options.id) {\n                this.element.id = this.options.id;\n            }\n            this.element.className = 'a-color-picker';\n            // // se falsy viene nascosto .a-color-picker-rgb\n            // if (!this.options.showRGB) this.element.className += ' hide-rgb';\n            // // se falsy viene nascosto .a-color-picker-hsl\n            // if (!this.options.showHSL) this.element.className += ' hide-hsl';\n            // // se falsy viene nascosto .a-color-picker-single-input (css hex)\n            // if (!this.options.showHEX) this.element.className += ' hide-single-input';\n            // // se falsy viene nascosto .a-color-picker-a\n            // if (!this.options.showAlpha) this.element.className += ' hide-alpha';\n            this.element.innerHTML = HTML_BOX;\n            container.appendChild(this.element);\n            // preparo il canvas con tutto lo spettro del HUE (da 0 a 360)\n            // in base al valore selezionato su questo canvas verrà disegnato il canvas per SL\n            const hueBar = this.element.querySelector('.a-color-picker-h');\n            this.setupHueCanvas(hueBar);\n            this.hueBarHelper = canvasHelper(hueBar);\n            this.huePointer = this.element.querySelector('.a-color-picker-h+.a-color-picker-dot');\n            // preparo il canvas per SL (saturation e luminance)\n            const slBar = this.element.querySelector('.a-color-picker-sl');\n            this.setupSlCanvas(slBar);\n            this.slBarHelper = canvasHelper(slBar);\n            this.slPointer = this.element.querySelector('.a-color-picker-sl+.a-color-picker-dot');\n            // preparo il box della preview\n            this.preview = this.element.querySelector('.a-color-picker-preview');\n            this.setupClipboard(this.preview.querySelector('.a-color-picker-clipbaord'));\n            // prearo gli input box\n            if (this.options.showHSL) {\n                this.setupInput(this.inputH = this.element.querySelector('.a-color-picker-hsl>input[nameref=H]'));\n                this.setupInput(this.inputS = this.element.querySelector('.a-color-picker-hsl>input[nameref=S]'));\n                this.setupInput(this.inputL = this.element.querySelector('.a-color-picker-hsl>input[nameref=L]'));\n            } else {\n                this.element.querySelector('.a-color-picker-hsl').remove();\n            }\n            if (this.options.showRGB) {\n                this.setupInput(this.inputR = this.element.querySelector('.a-color-picker-rgb>input[nameref=R]'));\n                this.setupInput(this.inputG = this.element.querySelector('.a-color-picker-rgb>input[nameref=G]'));\n                this.setupInput(this.inputB = this.element.querySelector('.a-color-picker-rgb>input[nameref=B]'));\n            } else {\n                this.element.querySelector('.a-color-picker-rgb').remove();\n            }\n            // preparo l'input per il formato hex css\n            if (this.options.showHEX) {\n                this.setupInput(this.inputRGBHEX = this.element.querySelector('input[nameref=RGBHEX]'));\n            } else {\n                this.element.querySelector('.a-color-picker-rgbhex').remove();\n            }\n            // preparo la palette con i colori predefiniti\n            //  (palette può contenere sia un Array che una stringa, entrambi con prop length)\n            if (this.options.paletteEditable || (this.options.palette && this.options.palette.length > 0)) {\n                this.setPalette(this.paletteRow = this.element.querySelector('.a-color-picker-palette'));\n            } else {\n                // #17 se l'elemento della palette è rimosso non posso modificarne il contenuto a posteriori\n                // rimuovo l'elemento dal DOM ma non lo elimino, potrebbe servirmi in seguito\n                this.paletteRow = this.element.querySelector('.a-color-picker-palette');\n                this.paletteRow.remove();\n            }\n            // preparo in canvas per l'opacità\n            if (this.options.showAlpha) {\n                this.setupAlphaCanvas(this.element.querySelector('.a-color-picker-a'));\n                this.alphaPointer = this.element.querySelector('.a-color-picker-a+.a-color-picker-dot');\n            } else {\n                this.element.querySelector('.a-color-picker-alpha').remove();\n            }\n            this.element.style.width = `${this.options.slBarSize[0]}px`;\n            // imposto il colore iniziale\n            this.onValueChanged(COLOR, this.options.color);\n        } else {\n            throw new Error(`Container not found: ${this.options.attachTo}`);\n        }\n    }\n\n    setupHueCanvas(canvas) {\n        canvas.width = this.options.hueBarSize[0];\n        canvas.height = this.options.hueBarSize[1];\n        // disegno sul canvas applicando un gradiente lineare che copra tutti i possibili valori di HUE\n        //  quindi ci vogliono 361 stop (da 0 a 360), mantendo fisse S e L\n        const ctx = canvas.getContext('2d'),\n            gradient = ctx.createLinearGradient(0, 0, this.options.hueBarSize[0], 0),\n            step = 1 / 360;\n        // aggiungo tutti i 361 step al gradiente\n        for (let ii = 0; ii <= 1; ii += step) {\n            gradient.addColorStop(ii, `hsl(${360 * ii}, 100%, 50%)`);\n        }\n        ctx.fillStyle = gradient;\n        ctx.fillRect(0, 0, this.options.hueBarSize[0], this.options.hueBarSize[1]);\n        // gestisco gli eventi per la selezione del valore e segnalo il cambiamento tramite callbak\n        // una volta che il puntatore è premuto sul canvas (mousedown)\n        // intercetto le variazioni nella posizione del puntatore (mousemove)\n        // relativamente al document, in modo che il puntatore in movimento possa uscire dal canvas\n        // una volta sollevato (mouseup) elimino i listener\n        const onMouseMove = (e) => {\n            const x = limit(e.clientX - canvas.getBoundingClientRect().left, 0, this.options.hueBarSize[0]),\n                hue = Math.round(x * 360 / this.options.hueBarSize[0]);\n            this.huePointer.style.left = (x - 7) + 'px';\n            this.onValueChanged(HUE, hue);\n        };\n        const onMouseUp = () => {\n            // rimuovo i listener, verranno riattivati al prossimo mousedown\n            document.removeEventListener('mousemove', onMouseMove);\n            document.removeEventListener('mouseup', onMouseUp);\n        };\n        // mouse down sul canvas: intercetto il movimento, smetto appena il mouse viene sollevato\n        canvas.addEventListener('mousedown', (e) => {\n            onMouseMove(e);\n            document.addEventListener('mousemove', onMouseMove);\n            document.addEventListener('mouseup', onMouseUp);\n        });\n    }\n\n    setupSlCanvas(canvas) {\n        canvas.width = this.options.slBarSize[0];\n        canvas.height = this.options.slBarSize[1];\n        // gestisco gli eventi per la selezione del valore e segnalo il cambiamento tramite callbak\n        // una volta che il puntatore è premuto sul canvas (mousedown)\n        // intercetto le variazioni nella posizione del puntatore (mousemove)\n        // relativamente al document, in modo che il puntatore in movimento possa uscire dal canvas\n        // una volta sollevato (mouseup) elimino i listener\n        const onMouseMove = (e) => {\n            const x = limit(e.clientX - canvas.getBoundingClientRect().left, 0, this.options.slBarSize[0] - 1),\n                y = limit(e.clientY - canvas.getBoundingClientRect().top, 0, this.options.slBarSize[1] - 1),\n                c = this.slBarHelper.grabColor(x, y);\n            // console.log('grab', x, y, c)\n            this.slPointer.style.left = (x - 7) + 'px';\n            this.slPointer.style.top = (y - 7) + 'px';\n            this.onValueChanged(RGB, c);\n        };\n        const onMouseUp = () => {\n            // rimuovo i listener, verranno riattivati al prossimo mousedown\n            document.removeEventListener('mousemove', onMouseMove);\n            document.removeEventListener('mouseup', onMouseUp);\n        };\n        // mouse down sul canvas: intercetto il movimento, smetto appena il mouse viene sollevato\n        canvas.addEventListener('mousedown', (e) => {\n            onMouseMove(e);\n            document.addEventListener('mousemove', onMouseMove);\n            document.addEventListener('mouseup', onMouseUp);\n        });\n    }\n\n    setupAlphaCanvas(canvas) {\n        canvas.width = this.options.alphaBarSize[0];\n        canvas.height = this.options.alphaBarSize[1];\n        // disegno sul canvas con un gradiente che va dalla piena trasparenza al pieno opaco\n        const ctx = canvas.getContext('2d'),\n            gradient = ctx.createLinearGradient(0, 0, canvas.width - 1, 0);\n        gradient.addColorStop(0, `hsla(0, 0%, 50%, 0)`);\n        gradient.addColorStop(1, `hsla(0, 0%, 50%, 1)`);\n        ctx.fillStyle = gradient;\n        ctx.fillRect(0, 0, this.options.alphaBarSize[0], this.options.alphaBarSize[1]);\n        // gestisco gli eventi per la selezione del valore e segnalo il cambiamento tramite callbak\n        // una volta che il puntatore è premuto sul canvas (mousedown)\n        // intercetto le variazioni nella posizione del puntatore (mousemove)\n        // relativamente al document, in modo che il puntatore in movimento possa uscire dal canvas\n        // una volta sollevato (mouseup) elimino i listener\n        const onMouseMove = (e) => {\n            const x = limit(e.clientX - canvas.getBoundingClientRect().left, 0, this.options.alphaBarSize[0]),\n                alpha = +(x / this.options.alphaBarSize[0]).toFixed(2);\n            this.alphaPointer.style.left = (x - 7) + 'px';\n            this.onValueChanged(ALPHA, alpha);\n        };\n        const onMouseUp = () => {\n            // rimuovo i listener, verranno riattivati al prossimo mousedown\n            document.removeEventListener('mousemove', onMouseMove);\n            document.removeEventListener('mouseup', onMouseUp);\n        };\n        // mouse down sul canvas: intercetto il movimento, smetto appena il mouse viene sollevato\n        canvas.addEventListener('mousedown', (e) => {\n            onMouseMove(e);\n            document.addEventListener('mousemove', onMouseMove);\n            document.addEventListener('mouseup', onMouseUp);\n        });\n    }\n\n    setupInput(input) {\n        const min = +input.min,\n            max = +input.max,\n            prop = input.getAttribute(\"nameref\");\n        if (input.hasAttribute('select-on-focus')) {\n            input.addEventListener('focus', () => {\n                //non funziona in IE/Edge\n                input.select();\n            });\n        }\n        if (input.type === 'text') {\n            input.addEventListener('change', () => {\n                this.onValueChanged(prop, input.value);\n            });\n        } else {\n            if (IS_EDGE || IS_IE11) {\n                // edge modifica il valore con le frecce MA non scatena l'evento change\n                // quindi le intercetto impostando e.returnValue a false in modo\n                // che non il valore non venga modificato anche da edge subito dopo il keydown\n                input.addEventListener('keydown', (e) => {\n                    if (e.key === 'Up') {\n                        input.value = limit((+input.value) + 1, min, max);\n                        this.onValueChanged(prop, input.value);\n                        e.returnValue = false;\n                    } else if (e.key === 'Down') {\n                        input.value = limit((+input.value) - 1, min, max);\n                        this.onValueChanged(prop, input.value);\n                        e.returnValue = false;\n                    }\n                });\n            }\n            input.addEventListener('change', () => {\n                const value = +input.value;\n                this.onValueChanged(prop, limit(value, min, max));\n            });\n        }\n    }\n\n    setupClipboard(input) {\n        // l'input ricopre completamente la preview ma è totalmente trasparente\n        input.title = 'click to copy';\n        input.addEventListener('click', () => {\n            // non uso direttamente inputRGBHEX perchè potrebbe contenere un colore non valido\n            //  converto in hexcss4 quindi aggiunge anche il valore hex dell'alpha ma solo se significativo (0<=a<1)\n            input.value = parseColor([this.R, this.G, this.B, this.A], 'hexcss4');\n            input.select();\n            document.execCommand('copy');\n        });\n    }\n\n    setPalette(/** @type {Element} */ row) {\n        // indica se considerare il canale alpha nei controlli della palette\n        // se 'auto' dipende dall'opzione showAlpha (se true allora alpha è considerata anche nella palette)\n        const useAlphaInPalette = this.options.useAlphaInPalette === 'auto' ? this.options.showAlpha : this.options.useAlphaInPalette;\n        // palette è una copia di this.options.palette\n        let palette = null;\n        switch (this.options.palette) {\n            case 'PALETTE_MATERIAL_500':\n                palette = PALETTE_MATERIAL_500;\n                break;\n            case 'PALETTE_MATERIAL_CHROME':\n                palette = PALETTE_MATERIAL_CHROME;\n                break;\n            default:\n                palette = ensureArray(this.options.palette);\n                break;\n        }\n        if (this.options.paletteEditable || palette.length > 0) {\n            const addColorToPalette = (color, refElement, fire) => {\n                // se il colore è già presente, non creo un nuovo <div> ma sposto quello esistente in coda\n                const el = row.querySelector('.a-color-picker-palette-color[data-color=\"' + color + '\"]') ||\n                    document.createElement('div');\n                el.className = 'a-color-picker-palette-color';\n                el.style.backgroundColor = color;\n                el.setAttribute('data-color', color);\n                el.title = color;\n                row.insertBefore(el, refElement);\n                this.palette[color] = true;\n                if (fire) {\n                    this.onPaletteColorAdd(color);\n                }\n            };\n            const removeColorToPalette = (element, fire) => {\n                // se element è nullo elimino tutti i colori\n                if (element) {\n                    row.removeChild(element);\n                    this.palette[element.getAttribute('data-color')] = false;\n                    if (fire) {\n                        this.onPaletteColorRemove(element.getAttribute('data-color'));\n                    }\n                } else {\n                    row.querySelectorAll('.a-color-picker-palette-color[data-color]').forEach(el => {\n                        row.removeChild(el);\n                    });\n                    Object.keys(this.palette).forEach(k => {\n                        this.palette[k] = false;\n                    });\n                    if (fire) {\n                        this.onPaletteColorRemove();\n                    }\n                }\n            };\n            // solo i colori validi vengono aggiunti alla palette\n            palette.map(c => parseColor(c, useAlphaInPalette ? 'rgbcss4' : 'hex'))\n                .filter(c => !!c)\n                .forEach(c => addColorToPalette(c));\n            // in caso di palette editabile viene aggiunto un pulsante + che serve ad aggiungere il colore corrente\n            if (this.options.paletteEditable) {\n                const el = document.createElement('div');\n                el.className = 'a-color-picker-palette-color a-color-picker-palette-add';\n                el.innerHTML = '+';\n                row.appendChild(el);\n                // gestisco eventi di aggiunta/rimozione/selezione colori\n                row.addEventListener('click', (e) => {\n                    if (/a-color-picker-palette-add/.test(e.target.className)) {\n                        if (e.shiftKey) {\n                            // rimuove tutti i colori\n                            removeColorToPalette(null, true);\n                        } else if (useAlphaInPalette) {\n                            // aggiungo il colore e triggero l'evento 'oncoloradd'\n                            addColorToPalette(parseColor([this.R, this.G, this.B, this.A], 'rgbcss4'), e.target, true);\n                        } else {\n                            // aggiungo il colore e triggero l'evento 'oncoloradd'\n                            addColorToPalette(rgbToHex(this.R, this.G, this.B), e.target, true);\n                        }\n                    } else if (/a-color-picker-palette-color/.test(e.target.className)) {\n                        if (e.shiftKey) {\n                            // rimuovo il colore e triggero l'evento 'oncolorremove'\n                            removeColorToPalette(e.target, true);\n                        } else {\n                            // visto che il colore letto da backgroundColor risulta nel formato rgb()\n                            // devo usare il valore hex originale\n                            this.onValueChanged(COLOR, e.target.getAttribute('data-color'));\n                        }\n                    }\n                });\n            } else {\n                // gestisco il solo evento di selezione del colore\n                row.addEventListener('click', (e) => {\n                    if (/a-color-picker-palette-color/.test(e.target.className)) {\n                        // visto che il colore letto da backgroundColor risulta nel formato rgb()\n                        // devo usare il valore hex originale\n                        this.onValueChanged(COLOR, e.target.getAttribute('data-color'));\n                    }\n                });\n            }\n        } else {\n            // la palette con i colori predefiniti viene nasconsta se non ci sono colori\n            row.style.display = 'none';\n        }\n    }\n\n    updatePalette(palette) {\n        // elimino tutti i riferimenti all'attuale palette\n        this.paletteRow.innerHTML = '';\n        this.palette = { };\n        // se l'elemento contenitore della palette è stato rimosso (nel costruttore), lo reintegro\n        if (!this.paletteRow.parentElement) {\n            this.element.appendChild(this.paletteRow);\n        }\n        // aggiorno le opzioni e ricreo i controlli\n        this.options.palette = palette;\n        this.setPalette(this.paletteRow);\n    }\n\n    onValueChanged(prop, value, options = { silent: false }) {\n        // console.log(prop, value);\n        switch (prop) {\n            case HUE:\n                this.H = value;\n                [this.R, this.G, this.B] = hslToRgb(this.H, this.S, this.L);\n                this.slBarHelper.setHue(value);\n                this.updatePointerH(this.H);\n                this.updateInputHSL(this.H, this.S, this.L);\n                this.updateInputRGB(this.R, this.G, this.B);\n                this.updateInputRGBHEX(this.R, this.G, this.B);\n                break;\n            case SATURATION:\n                this.S = value;\n                [this.R, this.G, this.B] = hslToRgb(this.H, this.S, this.L);\n                this.updatePointerSL(this.H, this.S, this.L);\n                this.updateInputHSL(this.H, this.S, this.L);\n                this.updateInputRGB(this.R, this.G, this.B);\n                this.updateInputRGBHEX(this.R, this.G, this.B);\n                break;\n            case LUMINANCE:\n                this.L = value;\n                [this.R, this.G, this.B] = hslToRgb(this.H, this.S, this.L);\n                this.updatePointerSL(this.H, this.S, this.L);\n                this.updateInputHSL(this.H, this.S, this.L);\n                this.updateInputRGB(this.R, this.G, this.B);\n                this.updateInputRGBHEX(this.R, this.G, this.B);\n                break;\n            case RED:\n                this.R = value;\n                [this.H, this.S, this.L] = rgbToHsl(this.R, this.G, this.B);\n                this.slBarHelper.setHue(this.H);\n                this.updatePointerH(this.H);\n                this.updatePointerSL(this.H, this.S, this.L);\n                this.updateInputHSL(this.H, this.S, this.L);\n                this.updateInputRGBHEX(this.R, this.G, this.B);\n                break;\n            case GREEN:\n                this.G = value;\n                [this.H, this.S, this.L] = rgbToHsl(this.R, this.G, this.B);\n                this.slBarHelper.setHue(this.H);\n                this.updatePointerH(this.H);\n                this.updatePointerSL(this.H, this.S, this.L);\n                this.updateInputHSL(this.H, this.S, this.L);\n                this.updateInputRGBHEX(this.R, this.G, this.B);\n                break;\n            case BLUE:\n                this.B = value;\n                [this.H, this.S, this.L] = rgbToHsl(this.R, this.G, this.B);\n                this.slBarHelper.setHue(this.H);\n                this.updatePointerH(this.H);\n                this.updatePointerSL(this.H, this.S, this.L);\n                this.updateInputHSL(this.H, this.S, this.L);\n                this.updateInputRGBHEX(this.R, this.G, this.B);\n                break;\n            case RGB:\n                [this.R, this.G, this.B] = value;\n                [this.H, this.S, this.L] = rgbToHsl(this.R, this.G, this.B);\n                this.updateInputHSL(this.H, this.S, this.L);\n                this.updateInputRGB(this.R, this.G, this.B);\n                this.updateInputRGBHEX(this.R, this.G, this.B);\n                break;\n            case RGBA_USER:\n                [this.R, this.G, this.B, this.A] = value;\n                [this.H, this.S, this.L] = rgbToHsl(this.R, this.G, this.B);\n                this.slBarHelper.setHue(this.H);\n                this.updatePointerH(this.H);\n                this.updatePointerSL(this.H, this.S, this.L);\n                this.updateInputHSL(this.H, this.S, this.L);\n                this.updateInputRGB(this.R, this.G, this.B);\n                this.updateInputRGBHEX(this.R, this.G, this.B);\n                this.updatePointerA(this.A);\n                break;\n            case HSLA_USER:\n                [this.H, this.S, this.L, this.A] = value;\n                [this.R, this.G, this.B] = hslToRgb(this.H, this.S, this.L);\n                this.slBarHelper.setHue(this.H);\n                this.updatePointerH(this.H);\n                this.updatePointerSL(this.H, this.S, this.L);\n                this.updateInputHSL(this.H, this.S, this.L);\n                this.updateInputRGB(this.R, this.G, this.B);\n                this.updateInputRGBHEX(this.R, this.G, this.B);\n                this.updatePointerA(this.A);\n                break;\n            case RGBHEX:\n                [this.R, this.G, this.B] = cssColorToRgb(value) || [this.R, this.G, this.B];\n                [this.H, this.S, this.L] = rgbToHsl(this.R, this.G, this.B);\n                this.slBarHelper.setHue(this.H);\n                this.updatePointerH(this.H);\n                this.updatePointerSL(this.H, this.S, this.L);\n                this.updateInputHSL(this.H, this.S, this.L);\n                this.updateInputRGB(this.R, this.G, this.B);\n                break;\n            case COLOR:\n                [this.R, this.G, this.B, this.A] = parseColor(value, 'rgba') || [0, 0, 0, 1];\n                [this.H, this.S, this.L] = rgbToHsl(this.R, this.G, this.B);\n                this.slBarHelper.setHue(this.H);\n                this.updatePointerH(this.H);\n                this.updatePointerSL(this.H, this.S, this.L);\n                this.updateInputHSL(this.H, this.S, this.L);\n                this.updateInputRGB(this.R, this.G, this.B);\n                this.updateInputRGBHEX(this.R, this.G, this.B);\n                this.updatePointerA(this.A);\n                break;\n            case ALPHA:\n                this.A = value;\n                break;\n        }\n        // this.onColorChanged(this.R, this.G, this.B, this.A);\n\n        if (this.A === 1) {\n            this.preview.style.backgroundColor = `rgb(${this.R},${this.G},${this.B})`;\n        } else {\n            this.preview.style.backgroundColor = `rgba(${this.R},${this.G},${this.B},${this.A})`;\n        }\n        // #21\n        if (!options || !options.silent) {\n            this.onchange && this.onchange(this.preview.style.backgroundColor);\n        }\n    }\n\n    // onColorChanged(r, g, b, a) {\n    //     if (a === 1) {\n    //         this.preview.style.backgroundColor = `rgb(${r},${g},${b})`;\n    //     } else {\n    //         this.preview.style.backgroundColor = `rgba(${r},${g},${b},${a})`;\n    //     }\n    //     // this.onchange && this.onchange();\n    //     this.onchange && this.onchange(this.preview.style.backgroundColor);\n    // }\n\n    onPaletteColorAdd(color) {\n        this.oncoloradd && this.oncoloradd(color);\n    }\n\n    onPaletteColorRemove(color) {\n        this.oncolorremove && this.oncolorremove(color);\n    }\n\n    updateInputHSL(h, s, l) {\n        if (!this.options.showHSL) return;\n\n        this.inputH.value = h;\n        this.inputS.value = s;\n        this.inputL.value = l;\n    }\n\n    updateInputRGB(r, g, b) {\n        if (!this.options.showRGB) return;\n\n        this.inputR.value = r;\n        this.inputG.value = g;\n        this.inputB.value = b;\n    }\n\n    updateInputRGBHEX(r, g, b) {\n        if (!this.options.showHEX) return;\n\n        this.inputRGBHEX.value = rgbToHex(r, g, b);\n    }\n\n    updatePointerH(h) {\n        const x = this.options.hueBarSize[0] * h / 360;\n        this.huePointer.style.left = (x - 7) + 'px';\n    }\n\n    updatePointerSL(h, s, l) {\n        const [r, g, b] = hslToRgb(h, s, l);\n        const [x, y] = this.slBarHelper.findColor(r, g, b);\n        if (x >= 0) {\n            this.slPointer.style.left = (x - 7) + 'px';\n            this.slPointer.style.top = (y - 7) + 'px';\n        }\n    }\n\n    updatePointerA(a) {\n        if (!this.options.showAlpha) return;\n\n        const x = this.options.alphaBarSize[0] * a;\n        this.alphaPointer.style.left = (x - 7) + 'px';\n    }\n}\n\nclass EventEmitter {\n    constructor(name) {\n        this.name = name;\n        this.listeners = [];\n    }\n    on(callback) {\n        if (callback) {\n            this.listeners.push(callback);\n        }\n    }\n    off(callback) {\n        if (callback) {\n            this.listeners = this.listeners.filter(cb => cb !== callback);\n        } else {\n            this.listeners = [];\n        }\n    }\n    emit(args, _this) {\n        const listeners = this.listeners.slice(0);\n        for (let ii = 0; ii < listeners.length; ii++) {\n            listeners[ii].apply(_this, args);\n        }\n    }\n}\n\n// function wrapEventCallback(ctrl, picker, eventName, cb) {\n//     if (cb && typeof cb === 'function') {\n//         picker['on' + eventName] = () => {\n//             cb.call(null, ctrl, ...arguments);\n//         };\n//     } else {\n//         picker['on' + eventName] = null;\n//     }\n// }\n\n/**\n * Crea il color picker.\n * Le opzioni sono:\n * - attachTo: elemento DOM al quale aggiungere il picker (default 'body')\n * - showHSL: indica se mostrare i campi per la definizione del colore in formato HSL (default true)\n * - showRGB: indica se mostrare i campi per la definizione del colore in formato RGB (default true)\n * - showHEX: indica se mostrare i campi per la definizione del colore in formato RGB HEX (default true)\n * - color: colore iniziale (default '#ff0000')\n *\n * @param      {Object}          element (opzionale) Un elemento HTML che andrà a contenere il picker\n * @param      {Object}          options  (opzionale) Le opzioni di creazione\n * @return     {Object}          ritorna un controller per impostare e recuperare il colore corrente del picker\n */\nfunction createPicker(element, options) {\n    let picker = new ColorPicker(element, options);\n    // gestione degli eventi: il \"controller\" assegna le callbak degli eventi ai rispettivi EventEmitter\n    // quando il picker triggera un evento,\n    //  il \"controller\" emette lo stesso evento tramite il rispettivo EventEmitter\n    let cbEvents = {\n        change: new EventEmitter('change'),\n        coloradd: new EventEmitter('coloradd'),\n        colorremove: new EventEmitter('colorremove')\n    };\n    let isChanged = true,\n        // memoize per la proprietà all\n        memAll = {};\n    // non permetto l'accesso diretto al picker\n    // ma ritorno un \"controller\" per eseguire solo alcune azioni (get/set colore, eventi, etc.)\n    const controller = {\n        get element() {\n            return picker.element;\n        },\n\n        get rgb() {\n            return [picker.R, picker.G, picker.B];\n        },\n\n        set rgb([r, g, b]) {\n            [r, g, b] = [limit(r, 0, 255), limit(g, 0, 255), limit(b, 0, 255)];\n            picker.onValueChanged(RGBA_USER, [r, g, b, 1]);\n        },\n\n        get hsl() {\n            return [picker.H, picker.S, picker.L];\n        },\n\n        set hsl([h, s, l]) {\n            [h, s, l] = [limit(h, 0, 360), limit(s, 0, 100), limit(l, 0, 100)];\n            picker.onValueChanged(HSLA_USER, [h, s, l, 1]);\n        },\n\n        get rgbhex() {\n            // return rgbToHex(picker.R, picker.G, picker.B);\n            return this.all.hex;\n        },\n\n        get rgba() {\n            return [picker.R, picker.G, picker.B, picker.A];\n        },\n\n        set rgba([r, g, b, a]) {\n            [r, g, b, a] = [limit(r, 0, 255), limit(g, 0, 255), limit(b, 0, 255), limit(a, 0, 1)];\n            picker.onValueChanged(RGBA_USER, [r, g, b, a]);\n        },\n\n        get hsla() {\n            return [picker.H, picker.S, picker.L, picker.A];\n        },\n\n        set hsla([h, s, l, a]) {\n            [h, s, l, a] = [limit(h, 0, 360), limit(s, 0, 100), limit(l, 0, 100), limit(a, 0, 1)];\n            picker.onValueChanged(HSLA_USER, [h, s, l, a]);\n        },\n\n        /**\n         * Ritorna il colore corrente nel formato RGB HEX,\n         * oppure nella notazione rgba() con alpha != 1.\n         *\n         * @return     {string}  colore corrente\n         */\n        get color() {\n            // if (picker.A === 1) {\n            //     return this.rgbhex;\n            // } else {\n            //     return `rgba(${picker.R},${picker.G},${picker.B},${picker.A})`;\n            // }\n            return this.all.toString();\n        },\n\n        /**\n         * Imposta il colore corrente.\n         * Accetta:\n         * - il nome di un colore (https://developer.mozilla.org/en-US/docs/Web/CSS/color_value)\n         * - un colore espresso nel formato RGB HEX sia esteso (#ffdd00) che compatto (#fd0)\n         * - un array di interi [R,G,B]\n         *\n         * @param      {string|array}  color   il colore\n         */\n        set color(color) {\n            picker.onValueChanged(COLOR, color);\n        },\n\n        /**\n         * Importa il colore corrente.\n         * E' possibile passare un secondo parametro per indicare\n         * se si vuole impostare il colore in modo silente, cio senza scatenare eventi.\n         *\n         * @param {string|array} color il colore\n         * @param {boolean} silent se true il colore viene cambiato senza scatenare eventi, false altrimenti\n         */\n        setColor(color, silent = false) {\n            // modifico il colore senza scatenare alcun evento\n            picker.onValueChanged(COLOR, color, { silent })\n        },\n\n        /**\n         * @return  {Object}    oggetto contenente il colore corrente in tutti i formati noti a parseColor()\n         */\n        get all() {\n            if (isChanged) {\n                const rgba = [picker.R, picker.G, picker.B, picker.A];\n                // la conversione in stringa segue le regole della proprietà color\n                const ts = picker.A < 1 ? `rgba(${picker.R},${picker.G},${picker.B},${picker.A})` : rgbToHex(...rgba);\n                // passando un oggetto a parseColor come secondo parametro, lo riempirà con tutti i formati disponibili\n                memAll = parseColor(rgba, memAll);\n                memAll.toString = () => ts;\n                isChanged = false;\n            }\n            // devo per forza passare una copia, altrimenti memAll può esssere modificato dall'esterno\n            return Object.assign({}, memAll);\n        },\n\n        /**\n         * @deprecated\n         */\n        get onchange() {\n            return cbEvents.change && cbEvents.change.listeners[0];\n        },\n\n        /**\n         * @deprecated  usare on('change', cb)\n         */\n        set onchange(cb) {\n            // wrapEventCallback(this, picker, 'change', cb);\n            // cbEvents['change'] = cb;\n            this.off('change').on('change', cb);\n        },\n\n        /**\n         * @deprecated\n         */\n        get oncoloradd() {\n            return cbEvents.coloradd && cbEvents.coloradd.listeners[0];\n        },\n\n        /**\n         * @deprecated  usare on('coloradd', cb)\n         */\n        set oncoloradd(cb) {\n            // wrapEventCallback(this, picker, 'coloradd', cb);\n            // cbEvents['coloradd'] = cb;\n            this.off('coloradd').on('coloradd', cb);\n        },\n\n        /**\n         * @deprecated\n         */\n        get oncolorremove() {\n            return cbEvents.colorremove && cbEvents.colorremove.listeners[0];\n        },\n\n        /**\n         * @deprecated  usare on('colorremove', cb)\n         */\n        set oncolorremove(cb) {\n            // wrapEventCallback(this, picker, 'colorremove', cb);\n            // cbEvents['colorremove'] = cb;\n            this.off('colorremove').on('colorremove', cb);\n        },\n\n        /**\n         * Ritorna la palette dei colori.\n         *\n         * @return     {Array}  array di colori in formato hex\n         */\n        get palette() {\n            return Object.keys(picker.palette).filter(k => picker.palette[k]);\n        },\n\n        /**\n         * Imposta la palette di color\n         */\n        set palette(colors) {\n            picker.updatePalette(colors);\n        },\n\n        /**\n         * Mostra il picker.\n         */\n        show() {\n            picker.element.classList.remove('hidden');\n        },\n\n        /**\n         * Nasconde il picker\n         */\n        hide() {\n            picker.element.classList.add('hidden');\n        },\n\n        /**\n         * Mostra o nasconde il picker\n         */\n        toggle() {\n            picker.element.classList.toggle('hidden');\n        },\n\n        on(eventName, cb) {\n            if (eventName) {\n                cbEvents[eventName] && cbEvents[eventName].on(cb);\n            }\n            return this;\n        },\n\n        off(eventName, cb) {\n            if (eventName) {\n                cbEvents[eventName] && cbEvents[eventName].off(cb);\n            }\n            return this;\n        },\n\n        destroy() {\n            cbEvents.change.off()\n            cbEvents.coloradd.off()\n            cbEvents.colorremove.off()\n            picker.element.remove()\n            cbEvents = null\n            picker = null\n        }\n    };\n    // ogni volta che viene triggerato un evento, uso il corrispettivo EventEmitter per propagarlo a tutte le callback associate\n    //  le callback vengono richiamate con il \"controller\" come \"this\"\n    //  e il primo parametro è sempre il \"controller\" seguito da tutti i parametri dell'evento\n    picker.onchange = (...args) => {\n        isChanged = true; // così le proprietà in lettura dovranno ricalcolare il loro valore\n        cbEvents.change.emit([controller, ...args], controller);\n    };\n    picker.oncoloradd = (...args) => {\n        cbEvents.coloradd.emit([controller, ...args], controller);\n    };\n    picker.oncolorremove = (...args) => {\n        cbEvents.colorremove.emit([controller, ...args], controller);\n    };\n    // TOOD: trovare un altro nome a ctrl, troppo comune\n    // TODO: definirla come readonly\n    picker.element.ctrl = controller;\n    return controller;\n}\n\n/**\n *\n * @param {any} selector\n * @param {object} options\n * @return  un Array di controller così come restituito da createPicker()\n */\nfunction from(selector, options) {\n    // TODO: gestire eventuali errori nella creazione del picker\n    const pickers = parseElements(selector).map((el, index) => {\n        const picker = createPicker(el, options);\n        picker.index = index;\n        return picker;\n    });\n    pickers.on = function (eventName, cb) {\n        pickers.forEach(picker => picker.on(eventName, cb));\n        return this;\n    };\n    pickers.off = function (eventName) {\n        pickers.forEach(picker => picker.off(eventName));\n        return this;\n    };\n    return pickers;\n}\n\nif (typeof window !== 'undefined') {\n    // solo in ambiente browser inserisco direttamente nella pagina html il css\n    //  per sicurezza controllo che non sia già presente\n    if (!document.querySelector('head>style[data-source=\"a-color-picker\"]')) {\n        // eslint-disable-next-line global-require,  no-undef\n        const css = require('./acolorpicker.css').toString();\n        const style = document.createElement('style');\n        style.setAttribute('type', 'text/css');\n        style.setAttribute('data-source', 'a-color-picker');\n        style.innerHTML = css;\n        // TODO: verificare che esista <head>\n        document.querySelector('head').appendChild(style);\n    }\n}\n\nexport {\n    createPicker,\n    from,\n    parseColorToRgb,\n    parseColorToRgba,\n    parseColorToHsl,\n    parseColorToHsla,\n    parseColor,\n    rgbToHex,\n    hslToRgb,\n    rgbToHsl,\n    rgbToHsv,\n    rgbToInt,\n    intToRgb,\n    getLuminance,\n    COLOR_NAMES,\n    PALETTE_MATERIAL_500,\n    PALETTE_MATERIAL_CHROME,\n    VERSION\n};","/*!\n * isobject <https://github.com/jonschlinkert/isobject>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nmodule.exports = function isObject(val) {\n  return val != null && typeof val === 'object' && Array.isArray(val) === false;\n};\n"],"mappings":"AACA;;;;;;ACQA;;;;;;;ACwBA;;;;;;ACxBA","sourceRoot":""}